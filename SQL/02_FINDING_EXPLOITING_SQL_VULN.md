# Finding SQL Injection Vulnerabilities

## Black Box vs White Box Testing

1. **Black Box Testing**: The pentester (penetration tester) has
very little access to the web application's internals.
Usually, the only information available is the URL.

- Access the URL and map the application, test the endpoints,
analyze the DevTools information.

- Start off by running scans from tools such as: Sonarqube,
Fortify and Checkmarx.

- Submit SQL-specific characters such as: ' or ", and look
for errors or other anomalies, which give out information
about how the backend works.

- Submit BOOLEAN conditions, such as "OR 1=1", "OR 1=2",
looking for different behaviors to gain more information
about the application.

- Submit payloads designed to trigger **time delays**
when executed within a SQL query.

- Submit OAST (Out-of-band) payloads designed to trigger an
out-of-band network interaction when executed within a
SQL query, and monitor for any resulting interactions.

2. **White Box Testing**: Full access to the application's
components and source code.

- Enable web server logging

- Enable database logging

- Map the application (functionality and architecture)

- Regex search on all instances in the code that talk to the
database.

- Code Review ---> Follow the code path for all input
vectors.

- Test any potential SQL Injection Vulnerabilities.

3. **Gray Box Testing**: White + Black Box Pentesting.

# Exploiting SQL Injection Vulnerabilities

### Error-based: 

- Submit SQL-specific characters such as ' or
" and look for errors.

### Union-based:

The number, order and data type of the
columns from the 2 queries must match.
Incrementally inject a series of `ORDER BY` clauses until
you get an error or observe different behavior, for example:

```sql
ORDER BY 1 -- OK
ORDER BY 2 -- OK
ORDER BY 3 -- The ORDER BY position number 3 is out of range.

-- Find out the number of columns required by using NULLs
... UNION SELECT NULL
... UNION SELECT NULL, NULL
... UNION SELECT NULL, NULL, NULL -- Does it have 3 columns?
```

### Finding the useful data types:

Payload example with 2 columns:

1. `' UNION SELECT 'a', NULL--`

Output: 

```log
Conversion Failed when converting the VARCHAR value 'a' to
data type int.
```

2. `' UNION SELECT NULL, 'a'--` ...

### Boolean-based (scripting is useful)

- Submit a boolean condition that evaluates to `FALSE`, then
`TRUE`, and take note of the response.

### Time-based

- Submit a payload that pauses the application for a
specified period of time.

- Submit boolean conditions and monitor the response time.
Delay ---> The answer to the question is TRUE.  
No delay ---> The answer to the question is FALSE.

### Out-of-Band

- Submit OAST payloads designed to trigger an out-of-band
network interaction when executed within an SQL query, and
monitor for any resulting interactions.


# How to prevent SQL Injection Vulnerabilities

### Primary Defenses:

Option 1: Use of **Parameterized Queries**
(Prepared Statements for Java) 

**VULNERABLE CODE**:
```java
String query = "SELECT account_balance FROM user_data WHERE user_name = "
+ request.getParameter("customerName"); // UNSAFE

try {
    Statement st = connection.createStatement(...);
    ResultSet results = st.executeQuery(query);
}
```

**SAFER CODE**:

```java
// This should be validated too
String custname = request.getParameter("customerName");

String query = "SELECT account_balance FROM user_data WHERE user_name = ? ";
PreparedStatement pstmt = connection.prepareStatement(query);
pstmt.setString(1, custname); // Injects INPUT as DATA, not as SQL code

ResultSet results = pstmt.executeQuery();
```

Option 2: Use of STORED PROCEURES (Partial)  
Option 3: Whitelist Input Validation (Partial)  
Option 4: Escaping All User Supplied Input (Partial)

[+] Enforcing the Principle of Least Privilege.

## Defense in Depth

[+] Provide multiple layers of security.

[+] Any unnecessary default functionality in the database
must be removed or disabled.

[+] Ensure CIS benchmark for the database in use is applied.

[+] Whitelist input validation.

**EOF**